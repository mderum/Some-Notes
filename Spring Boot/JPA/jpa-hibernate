
Projection api -> 
 return only specific fields without exposing all entity details in response 

FLOW -> interface or DTO > repo with methods > call() 

Interface based->  few fields , readonly
  1:
  public interface UserView{
    Long getId();
    String getName();
  } 


  2:
  public UserRepo implements JpaRepository<User,Long> {
      List<UserView> findById(Long id);
  }
-----------------



DTO based  ->>  cusomt logic , modification , business logics 

UserViewDTO{
private Long id;
private String name;

//cons 
//gettters
}

  public UserRepo implements JpaRepository<User,Long> {
      @Query(select new com.ex.UserViewDTO(u.id,u.name ) from User u)
      List<UserViewDTO> findAllUsers();
  }

 @Query(select new com.ex.UserViewDTO(u.id,u.name ) from User u where u.cat= :category)
      List<UserViewDTO> findAllUsers(@Param("category") String category);
----------


Dynamic or runtime resolution using single method   -> different views for different users 

<T> List<T> findBy(Class<T> type); 

findBy(UserView.class);
findBy(UserDTO.class);


------
combining 2 values from entity into one 
  @Transient
    private Integer totalVariable;


  public Integer getTotalVar() {
        int primary = fieldA != null ? fieldA : 0;
        int secondary = fieldB != null ? fieldB : 0;
        return primary + secondary;
    }

--


    @OneToMany(fetch = FetchType.EAGER)
    @JoinColumn(name = "field in other table on which relation is needed to be setup  ", referencedColumnName = "current_TAble column")
    private List<OtherEntity> otherEntity;


   
    @OneToOne(fetch = FetchType.EAGER)
    @JsonManagedReference
    @JoinColumn(name = "link", referencedColumnName = "inId",   insertable = false, updatable = false  // use these if you have the same coulmn in your current 
entity already )
    private LinkedTable linkedTable;

@Column(name="something" , columnDefinition = "uuid" ) 



---

matching or filtering data from table 

Specification<Your Entity Type >  search ( String or some input ) { 

return  ( root , query , builder ) -> {

Prediacte p = builder.or(
builder.like( builder.lower(root.get("emailAddress")  )  , "%" + input.toLowerCase() + "%" ) ,
builder.like( builder.lower(root.get("nameLast")  )  , "%" + input.toLowerCase() + "%" ) 
);


return p;

}; 


filtering at level 2 of nested entities 

			Join<Object, Object> bJoin = root.join("transactions  //this is the name of field in level 1 entity  ", JoinType.LEFT //type of join);

	                builder.like(builder.concat(bJoin.get("transactionStatus"  //field in your java entity// ).as(String.class), ""), "%" + txnStatus+ "%")


----

use this specification in findAll (  spec , Pagable if needed ) ;


* put JPASEPCIFICATIONEXECUTOR < Entity>  if any issues

------


Pagable.of( page to skip , size of list to retur ) 
FindAll(pagable object just made )   > return Page<EntityObject> ;


---




