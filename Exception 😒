
Exception heirarchy: 


        Throwable: -> a super class to all below provides utility methods for stack trace , message , cause 

                Errors -> issues beyond program control like stack overflow, out of mem , no class def found , bootstrap method error 

                Exceptions: 

                        Checked:
                
                        IO Exception -> related to files , sockets , connections , host  , java.io
                        Reflective Ops -> illegal Access, class not found, no such method or field  , java.reflect


                        Unchecked: 
                        Runtime -> array and string index out of bound , null pointer , unsupported op, class cast , java.lang
        




throw -> throw a exception or throwable object 
throws -> used in method signature to declare that this method will throw exception


finally -> exectues after try catch. 
        -> cases when it will not execute->  System.exit(0) , errors like Out of Mem or stackOVerFlow , Thread.stop() force kill,





using Controller advice 

1. create custom classed for you exception if needed . 

EX:   class BlahBlahException extends RuntimeException {
        //any filed vars if needed 
        
        BlahBlahException(String message) {
          super(message);
        }
}

2. implement handling machinism using ControllerAdvice annotation on a class with @ExceptionHandler(ExceptionClassName.class)

@ControllerAdvice
class BlahController{

@ExceptionHandler(BlahBlahException.class)
public ResponseEntity<?> handleBlahBlahException(BlahBlahException ex) {

Map<String , Object> body = new HashMap<>();
body.put("xyzField",ex.getMessage());

return new ResponseEntity<>(body,HttpStatus.BAD_REQUEST);  
}


@ExceptionHandler(IllegalArgumentException.class)
public ResponseEntity< Map<String,Object> >  handleIllegalArgException( IllegalArgumentException ex) {

  return ResponseEntity<>(null, HttpStatus.NOT_FOUND);
  return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(null);

  return ResponseEntity.status().build;
  return ResponseEntity.badRequest().build;
}








}
