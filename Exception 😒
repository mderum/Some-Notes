
Exception heirarchy: 


        Throwable: -> a super class to all below provides utility methods for stack trace , message , cause 

                Errors -> issues beyond program control like stack overflow, out of mem , no class def found , bootstrap method error 

                Exceptions: 

                        Checked:
                
                        IO Exception -> related to files , sockets , connections , host  , java.io
                        Reflective Ops -> illegal Access, class not found, no such method or field  , java.reflect


                        Unchecked: 
                        Runtime -> array and string index out of bound , null pointer , unsupported op, class cast , java.lang
        




throw -> throw a exception or throwable object 
throws -> used in method signature to declare that this method will throw exception


finally -> exectues after try catch. 
        -> cases when it will not execute->  System.exit(0) , errors like Out of Mem or stackOVerFlow , Thread.stop() force kill,


try with resource->  auto close the resources ( files, sockets , connections ) must be implementing AutoClosable interface
                         no need to use finally for closing the resources, closed in reverse order 
                                auto close can fail in Stream errors or connection errors or unchecked exceptions in close()



Always catch child then parent exception , if not so compile time exeption will be there > unreachable code 


Propagation -> if not cathing , throw it > propagates to top layer up the stack
                , can hit main and print stack trace if not caught in middle and terminates program



Exception chaining -> make a cons ( message , throwable ) -> so wrap your low level ex to your custom or high level ex preserving context.







using Controller advice 

1. create custom classed for you exception if needed . 

EX:   class BlahBlahException extends RuntimeException {
        //any filed vars if needed 
        
        BlahBlahException(String message) {
          super(message);
        }
}

2. implement handling machinism using ControllerAdvice annotation on a class with @ExceptionHandler(ExceptionClassName.class)

@ControllerAdvice
class BlahController{

@ExceptionHandler(BlahBlahException.class)
public ResponseEntity<?> handleBlahBlahException(BlahBlahException ex) {

Map<String , Object> body = new HashMap<>();
body.put("xyzField",ex.getMessage());

return new ResponseEntity<>(body,HttpStatus.BAD_REQUEST);  
}


@ExceptionHandler(IllegalArgumentException.class)
public ResponseEntity< Map<String,Object> >  handleIllegalArgException( IllegalArgumentException ex) {

  return ResponseEntity<>(null, HttpStatus.NOT_FOUND);
  return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(null);

  return ResponseEntity.status().build;
  return ResponseEntity.badRequest().build;
}








}
